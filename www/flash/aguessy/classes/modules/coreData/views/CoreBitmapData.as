package modules.coreData.views{	import flash.display.BitmapData;	import flash.display.IBitmapDrawable;	import flash.filters.BitmapFilter;	import flash.geom.Point;	import flash.utils.ByteArray;	import flash.utils.IDataInput;	import flash.utils.IDataOutput;		import modules.coreData.CoreData;	import modules.coreData.DataInitializer;	import modules.coreData.geoms.Box;	import modules.coreData.geoms.ColorData;	import modules.coreData.geoms.Location;	import modules.coreData.geoms.MatrixData;	import modules.foundation.Type;					public class CoreBitmapData extends CoreData implements IBitmapDrawable	{		public function CoreBitmapData(source:Object=null)		{			super(source);		}		/**		 * Takes a source image and a filter object and generates the filtered image. This method relies on the behavior of 		 * built-in filter objects, which determine the destination rectangle that is affected by an input source rectangle.		 * After a filter is applied, the resulting image can be larger than the input image. For example, if you use a 		 * BlurFilter class to blur a source rectangle of (50,50,100,100) and a destination point of (10,10), the area that 		 * changes in the destination image is larger than (10,10,60,60) because of the blurring. This happens internally during 		 * the applyFilter() call. If the sourceRect parameter of the sourceBitmapData parameter is an interior region, such as 		 * (50,50,100,100) in a 200 x 200 image, the filter uses the source pixels outside the sourceRect parameter to generate 		 * the destination rectangle. If the BitmapData object and the object specified as the sourceBitmapData parameter are 		 * the same object, the application uses a temporary copy of the object to perform the filter. For best performance, 		 * avoid this situation.		 * 		 * @param	sourceBitmapData CoreBitmapData — The input bitmap image to use. The source image can be a different 		 * 											  BitmapData object or it can refer to the current BitmapData instance.		 * @param	sourceRect 	Box — A rectangle that defines the area of the source image to use as input.		 * @param	destPoint Location — The point within the destination image (the current BitmapData instance) that 		 * 									corresponds to the upper-left corner of the source rectangle.		 * @param	filter BitmapFilter — The filter object that you use to perform the filtering operation. Each type of 		 * 									filter has certain requirements, as follows:		 * 									BlurFilter — This filter can use source and destination images that are either 		 * 									opaque or transparent. If the formats of the images do not match, the copy of 		 * 									the source image that is made during the filtering matches the format of the 		 * 									destination image.		 * 									BevelFilter, DropShadowFilter, GlowFilter, ChromeFilter — The destination image 		 * 									of these filters must be a transparent image. Calling DropShadowFilter or GlowFilter 		 * 									creates an image that contains the alpha channel data of the drop shadow or glow. 		 * 									It does not create the drop shadow onto the destination image. If you use any of 		 * 									these filters with an opaque destination image, an exception is thrown.		 * 									ConvolutionFilter — This filter can use source and destination images that are 		 * 									either opaque or transparent.		 * 									ColorMatrixFilter — This filter can use source and destination images that are 		 * 									either opaque or transparent.		 * 									DisplacementMapFilter — This filter can use source and destination images that are 		 * 									either opaque or transparent, but the source and destination image formats must be 		 * 									the same.		 */		public function applyFilter(sourceBitmapData:CoreBitmapData, sourceRect:Box, destPoint:Location, filter:BitmapFilter):void		{			_bitmapData.applyFilter(sourceBitmapData.cloneBitmapData(), sourceRect.cloneRectangle(), destPoint.clonePoint(), filter);		}				/**		 * Returns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap.		 */		public function cloneBitmapData():BitmapData		{			return _bitmapData.clone();		}				/**		 * Adjusts the color values in a specified area of a bitmap image by using a ColorTransform object. If the rectangle 		 * matches the boundaries of the bitmap image, this method transforms the color values of the entire image.		 * 		 * @param	rect Box - 	A Box object that defines the area of the image in which the ColorData object is applied.		 * @param	colorTransform ColorData - A ColorData object that describes the color transformation values to apply.		 */			public function colorTransform(rect:Box, colorTransform:ColorData):void		{			_bitmapData.colorTransform(rect.cloneRectangle(), colorTransform.cloneColorTransform());		}				/**		 * 		 */		public function compare(otherBitmapData:CoreBitmapData):Object		{			return _bitmapData.compare(otherBitmapData.cloneBitmapData());		}				public function copyChannel(sourceBitmapData:CoreBitmapData, sourceRect:Box, destPoint:Location, sourceChannel:uint, destChannel:uint):void		{			_bitmapData.copyChannel(sourceBitmapData.cloneBitmapData(), sourceRect.cloneRectangle(), destPoint.clonePoint(), sourceChannel, destChannel);		}				public function copyPixels(sourceBitmapData:CoreBitmapData, sourceRect:Box, destPoint:Location, alphaBitmapData:CoreBitmapData = null, alphaPoint:Location = null, mergeAlpha:Boolean = false):void		{			_bitmapData.copyPixels(sourceBitmapData.cloneBitmapData(), sourceRect.cloneRectangle(), destPoint.clonePoint(), alphaBitmapData.cloneBitmapData(), alphaPoint.clonePoint(), mergeAlpha);		}				public function dispose():void		{			_bitmapData.dispose();		}				public function draw(source:IBitmapDrawable, matrix:MatrixData = null, colorTransform:ColorData = null, blendMode:String = null, clipRect:Box = null, smoothing:Boolean = false):void		{			_bitmapData.draw(source is CoreBitmapData ? CoreBitmapData(source).cloneBitmapData() : source, matrix.cloneMatrix(), colorTransform.cloneColorTransform(), blendMode, clipRect != null ? clipRect.cloneRectangle() : null, smoothing);		}				public function fillRect(rect:Box, color:uint):void		{			_bitmapData.fillRect(rect.cloneRectangle(), color);		}				public function floodFill(x:int, y:int, color:uint):void		{			_bitmapData.floodFill.apply(_bitmapData, arguments);		}				public function fromBitmapData(source:BitmapData):CoreBitmapData		{			_bitmapData = source.clone();			return this;		}				public function getColorBoundsRect(mask:uint, color:uint, findColor:Boolean = true):Box		{			return new Box().fromRect(_bitmapData.getColorBoundsRect.apply(_bitmapData, arguments));		}				public function getPixel(x:int, y:int):uint		{			return _bitmapData.getPixel.apply(_bitmapData, arguments);		}				public function getPixel32(x:int, y:int):uint		{			return _bitmapData.getPixel32.apply(_bitmapData, arguments);		}				public function getPixels(rect:Box):ByteArray		{			return _bitmapData.getPixels(rect.cloneRectangle());		}					public function hitTest(firstPoint:Location, firstAlphaThreshold:uint, secondObject:Object, secondBitmapDataPoint:Location = null, secondAlphaThreshold:uint = 1):Boolean		{			return _bitmapData.hitTest(firstPoint.clonePoint(), firstAlphaThreshold, secondObject, secondBitmapDataPoint != null ? secondBitmapDataPoint.clonePoint() : null, secondAlphaThreshold);		}					public function generateFilterRect(sourceRect:Box, filter:BitmapFilter):Box		{			return new Box().fromRect(_bitmapData.generateFilterRect(sourceRect.cloneRectangle(), filter));		}				public function lock():void		{			_bitmapData.lock();		}				public function merge(sourceBitmapData:CoreBitmapData, sourceRect:Box, destPoint:Location, redMultiplier:uint, greenMultiplier:uint, blueMultiplier:uint, alphaMultiplier:uint):void		{			_bitmapData.merge(sourceBitmapData.cloneBitmapData(), sourceRect.cloneRectangle(), destPoint.clonePoint(), redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier);		}				public function noise(randomSeed:int, low:uint = 0, high:uint = 255, channelOptions:uint = 7, grayScale:Boolean = false):void		{			_bitmapData.noise.apply(_bitmapData, arguments);		}				public function paletteMap(sourceBitmapData:CoreBitmapData, sourceRect:Box, destPoint:Point, redArray:Array = null, greenArray:Array = null, blueArray:Array = null, alphaArray:Array = null):void		{			_bitmapData.paletteMap(sourceBitmapData.cloneBitmapData(), sourceRect.cloneRectangle(), destPoint, redArray, greenArray, blueArray, alphaArray);		}				public function perlinNoise(baseX:Number, baseY:Number, numOctaves:uint, randomSeed:int, stitch:Boolean, fractalNoise:Boolean, channelOptions:uint = 7, grayScale:Boolean = false, offsets:Array = null):void		{			_bitmapData.perlinNoise.apply(_bitmapData, arguments);		}				public function pixelDissolve(sourceBitmapData:CoreBitmapData, sourceRect:Box, destPoint:Location, randomSeed:int = 0, numPixels:int = 0, fillColor:uint = 0):int		{			return _bitmapData.pixelDissolve(sourceBitmapData.cloneBitmapData(), sourceRect.cloneRectangle(), destPoint.clonePoint(), randomSeed, numPixels, fillColor);		}				override public function readExternal(input:IDataInput):void		{						width = input.readInt();			height = input.readInt();				transparent = input.readBoolean();			fillcolor = input.readInt();			if (bitmapDataReference is String)				bitmapDataReference = input.readUTF();			else if (bitmapDataReference is Object)				bitmapDataReference = Type.getClassName(input.readUTF());		}								public function scroll(x:int, y:int):void		{			_bitmapData.scroll.apply(_bitmapData, arguments);		}				public function setPixel(x:int, y:int, color:uint):void		{			_bitmapData.setPixel.apply(_bitmapData, arguments);		}				public function setPixel32(x:int, y:int, color:uint):void		{			_bitmapData.setPixel32.apply(_bitmapData, arguments);		}				public function setPixels(rect:Box, inputByteArray:ByteArray):void		{			_bitmapData.setPixels(rect.cloneRectangle(), inputByteArray);		}				public function threshold(sourceBitmapData:CoreBitmapData, sourceRect:Box, destPoint:Location, operation:String, threshold:uint, color:uint = 0, mask:uint = 0xFFFFFFFF, copySource:Boolean = false):uint		{			return _bitmapData.threshold(sourceBitmapData.cloneBitmapData(), sourceRect.cloneRectangle(), destPoint.clonePoint(), operation, threshold, color, mask, copySource);		}				public function unlock(changeRect:Box = null):void		{			_bitmapData.unlock(changeRect != null ? changeRect.cloneRectangle() : null);		}				public function update():void		{			var T:Class = resolveReference(_bitmapDataReference);			_bitmapData = new T(_width, _height, _transparent, _fillcolor) as BitmapData;		}				/**		 * 		 * @param	output		 */		override public function writeExternal(output:IDataOutput):void		{					output.writeInt(width);			output.writeInt(height);				output.writeBoolean(transparent);			output.writeUnsignedInt(fillcolor);			if (_bitmapDataReference is String)				output.writeUTF(bitmapDataReference as String);			else if (_bitmapDataReference is Object)				output.writeUTF(Type.getQualifiedName(bitmapDataReference));		}						public function get bitmapDataReference():Object		{			return _bitmapDataReference;		}				public function set bitmapDataReference(value:Object):void		{			_bitmapDataReference = value;			if (_bitmapData != null)				update();		}						public function get fillcolor():uint		{			return _fillcolor;					}						public function set fillcolor(value:uint):void		{			_fillcolor = value;					if (_bitmapData != null)				update();				}								public function get height():int		{			return _height;					}						public function set height(value:int):void		{			_height = value;				if (_bitmapData != null)				update();				}						public function get rect():Box		{			return new Box().fromRect(_bitmapData.rect);					}				public function get transparent():Boolean		{			return _transparent;		}				public function set transparent(value:Boolean):void		{			_transparent = value;			if (_bitmapData != null)				update();			}								public function get width():int		{			return _width;		}						public function set width(value:int):void		{			_width = value;					if (_bitmapData != null)				update();			}								override protected function getInitializer():Object		{			var o:Object = {};			getClass().accessors.forEach(function(el:*, i:int, arr:Array):void {				if (el.access != Type.READONLY) {					if (el.name == "width" || el.name == "height") 						o[el.name] = 1;					else if (el.name == "transparent") 						o[el.name] = false;						else if (el.name == "fillcolor") 						o[el.name] = 0;						else if (el.name == "bitmapDataReference") 						o[el.name] = "flash.display.BitmapData";												}							}, this);			return o;		}				protected function resolveReference(reference:Object=null):Class		{				if (reference != null) {				if (reference is String) {					return Type.getClassByName((reference as String));				} else if (reference is Class) {					_bitmapDataReference = Type.getQualifiedName(reference);					if (Type.isSubclassOf(reference as Class, BitmapData))													return reference as Class;					return Type.getClass(reference);				}			}			_bitmapDataReference = Type.getQualifiedName(BitmapData);			return BitmapData;		}				override protected function setup(source:Object):void		{					_initializer = DataInitializer.build(this, source);				update();		}				private var _bitmapData:BitmapData;		private var _bitmapDataReference:Object;		private var _height:int;				private var _fillcolor:uint;		private var _transparent:Boolean;				private var _width:int;	}}