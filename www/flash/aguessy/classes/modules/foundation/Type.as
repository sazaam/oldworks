package modules.foundation {		import flash.net.ObjectEncoding;	import flash.net.registerClassAlias;	import flash.system.ApplicationDomain;	import flash.utils.ByteArray;	import flash.utils.Dictionary;	import flash.utils.Proxy;	import flash.utils.describeType;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;	import flash.utils.getQualifiedSuperclassName;			/**	 * ...	 * @author biendo@fullsix.com	 */	public class Type 	{		public static const READONLY				:String = "readonly";		public static const READWRITE				:String = "readwrite";		public static const ACCESSOR				:String = ".";		public static const QUALIFIED_ACCESSOR		:String = "::";				public function Type(T:Object)		{			_definition = toXml(T);			//buggy here?			//_source = getClass(T);			_source = T.constructor;//work around		}        				/**		 * 		 * @param	instance		 * @param	T		 * @return		 */		public static function cast(instance:Object, T:Class):*		{			return instance as T;		}				public static function clone(instance:Object):* 		{			if (register(instance)) {				var clone:ByteArray = new ByteArray();				clone.writeObject(instance);				clone.position = 0;				return clone.readObject();			}			return null;		}				/**		 * 		 * @return		 */		public static function context():ApplicationDomain		{			return ApplicationDomain.currentDomain;		}						/**		 * Write a plain vanilla object to be an instance of the class		 * passed as the second variable.  This is not a recursive funtion		 * and will only work for the first level of nesting.  When you have		 * deeply nested objects, you first need to convert the nested		 * objects to class instances, and then convert the top level object.		 *		 * TODO: This method can be improved by making it recursive.  This would be		 * done by looking at the typeInfo returned from describeType and determining		 * which properties represent custom classes.  Those classes would then		 * be registerClassAlias'd using getDefinititonByName to get a reference,		 * and then objectToInstance would be called on those properties to complete		 * the recursive algorithm.		 *		 * @author biendo@fullsix.com		 * original sources : http://www.darronschall.com/weblog/archives/000247.cfm		 * @param 	instance Object - The plain object that should be converted.		 		 * @param 	T Class - The type to write the object to		 */				public static function encode(instance:Object, T:Class, encoding:int=-1):* 		{			var bytes:ByteArray = new ByteArray();			var coding:int = encoding == 0 || encoding == 3 ? encoding : ObjectEncoding.AMF0;			bytes.objectEncoding = coding;			// Find the objects and byetArray.writeObject them, adding in the			// class configuration variable name -- essentially, we're constructing			// and AMF packet here that contains the class information so that			// we can simplly byteArray.readObject the sucker for the translation			// Write out the bytes of the original object			var objBytes:ByteArray = new ByteArray();			objBytes.objectEncoding = coding;			objBytes.writeObject(instance);			// Register all of the classes so they can be decoded via AMF			if (register(T)) {				var typeInfo:XML = toXml(T);				var fullyQualifiedName:String = getClassPath(T);				// Write the new object information starting with the class information				//var len:int = fullyQualifiedName.length;				bytes.writeByte(0x10);  // 0x10 is AMF0 for "typed object (class instance)"				bytes.writeUTF(fullyQualifiedName);				// After the class name is set up, write the rest of the object				bytes.writeBytes(objBytes, 1);				// Read in the object with the class property added and return that				bytes.position = 0;				// This generates some ReferenceErrors of the object being passed in				// has properties that aren't in the class instance, and generates TypeErrors				// when property values cannot be converted to correct values (such as false				// being the value, when it needs to be a Date instead).  However, these				// errors are not thrown at runtime (and only appear in trace ouput when				// debugging), so a try/catch block isn't necessary.  I'm not sure if this				// classifies as a bug or not... but I wanted to explain why if you debug				// you might seem some TypeError or ReferenceError items appear.				return bytes.readObject();			}			return null;		}				/**		 * 		 * @param	expr		 * @return		 */		public static function eval(expr:String):Object		{			var newindex:int = expr.indexOf("new");			var startParenthesisIndex:int = expr.indexOf("(");			var endParenthesisIndex:int = expr.indexOf(")");			if(newindex == -1)				throw new TypeError("new instance Error");							if(startParenthesisIndex != -1 && endParenthesisIndex != -1) {				var min:int = startParenthesisIndex + 1;				var max:int = endParenthesisIndex - 1;				var T:Class = getClassByName(expr.substring(newindex + 4, startParenthesisIndex));				var xml:XML = toXml(T);				var parametersDesc:XMLList = xml.factory.constructor.*;				var parameters:Array = min == max ? [] : expr.substring(startParenthesisIndex + 1, endParenthesisIndex).split(",");				var l:int = parametersDesc.length();				var i:int;				for (i = 0; i<l; i++) {					var type:String = parametersDesc[i].@type;					switch(type) {						case "int":							parameters[i] = parseInt(parameters[i]);						break;						case "uint":							parameters[i] = parseFloat(parameters[i]);						break;						case "Boolean":							parameters[i] = Boolean(parameters[i]);						break;						case "String":						break;						default:						break;					}				}				return getInstance.apply(null, [T].concat(parameters));			}			return null;		}				/**		 * 		 * @param	instance		 * @return		 */		public static function format(instance:Object):String		{			var className:String = getClassName(instance);			var output:String = "[object "+ className + " = {";			getDefinition(instance).accessors.forEach(function(el:*, i:int, arr:Array):void {				if (i == arr.length - 1)					output += el.name + " : " + this[el.name] + "}]";				else					output += el.name + " : " + this[el.name] + ", ";			}, instance);				return output;					}				/**		 * 		 * @param	T		 * @return		 */		public static function fromXml(xml:XML):*		{			return null;		}				/**		 * 		 * @param	instance		 * @param	context		 * @return		 */		public static function getClass(instance:Object, context:ApplicationDomain = null):Class 		{			try {				return getClassByName(getClassPath(instance), context);			} catch ( e:ReferenceError ) {}			return null;        }		/**		 * 		 * @param	alias		 * @param	context		 * @return		 */		public static function getClassByName(alias:String, contextDomain:ApplicationDomain = null):Class 		{			try {				var T:Class, domain:ApplicationDomain;					domain = contextDomain || context();				while (!domain.hasDefinition(alias)) {					if (domain.parentDomain)						domain = domain.parentDomain;					else						break;				}				T = domain.getDefinition(alias) as Class;				return T;			} catch(e:ReferenceError) {}			return null;		}				/**         * Returns the class name as string of an object.         * @return the class name as string of an object.         */						public static function getClassName(instance:Object):String 		{			/*				if (o is Class) {					var s:String = o.toString();	// "[class SoAndSo]					return s.substring(7, s.length - 1);				}							 */			return parseName(getClassPath(instance));		}				/**         * Returns the package string representation of the specified instance passed in arguments.         * @param o the reference of the object to apply reflexion.         * @return the package string representation of the specified instance passed in arguments.         */        public static function getClassPackage(instance:Object):String         {            return parsePackage(getClassPath(instance));        }        		/**         * Returns the full path string representation of the specified instance passed in arguments (package + name).         * @param instance the reference of the object to apply reflexion.         * @return the full path string representation of the specified instance passed in arguments (package + name).         */        public static function getClassPath(instance:Object):String         {            return parsePath(getQualifiedName(instance));        } 				/**		 * 		 * @param	T		 * @return		 */		public static function getDefinition(T:Object):Type		{			return new Type(T);		}				/**		 * 		 * @param	superclass		 * @param	proto		 * @return		 */		public static function getGenericClass(superclass:Object, body:Object = null, overrides:Boolean = false, superclassArgs:Array=null, ...parameters:Array):Function 		{			// dynamic internal class            var subclass:Function;				//we have a class superclass type			if (superclass is Class) {				//ctor				subclass = function(...parameters:Array):Object 				{										if (this.constructor !== subclass)						throw SyntaxError("Constructor called as function");											var T:Class = superclass as Class;					var o:Object = Type.getInstance.apply(null, [T].concat(superclassArgs));					var desc:Type = Type.getDefinition(T);					//methods					desc.methods.forEach(function(el:*, i:int, arr:Array):void {						var name:String = el.name;						subclass.prototype[name] = o[name];					});					//members public					desc.accessors.forEach(function(el:*, i:int, arr:Array):void {						var field:String = el.name;						subclass.prototype[field] = o[field];					});					if (body != null) {						subclass.prototype = copyObject(body, subclass.prototype, overrides);						if (body.init != null)							this.init.apply(this, [].concat(parameters));					}					return this;				};							} else if (superclass is Function) {				subclass = superclass as Function;				subclass.prototype = body || {};				if (body != null)					subclass.prototype = copyObject(body, subclass.prototype, overrides);			} else {							}			subclass.prototype.superclass = superclass;			subclass.prototype.constructor = subclass;			return subclass;		}						/**		 * 		 * @param	T		 * @param	prototype		 * @return		 */		public static function getGenericInstance(superclass:Object, prototype:Object = null, overrides:Boolean = false, superclassArgs:Array=null, ...parameters:Array):Object		{			// dynamic ("old style") class definition            var subclass:Function = getGenericClass.apply(null, [superclass, prototype, overrides, superclassArgs].concat(parameters));            return getInstance.apply(null, [subclass].concat(parameters));		}				/**		 * 		 * @param	T		 * @return		 */		public static function getQualifiedName(T:*):String		{			return getQualifiedClassName(T);		}				/**		 * 		 * @param	T		 * @return		 */		public static function getQualifiedSuperName(T:*):String		{			return getQualifiedSuperclassName(T);		}				/**		 * 		 * @return		 */		public static function getStackTrace():String		{			//var stack:String = Debug.getStackTrace(Error);			var stack:String = (new Error()).getStackTrace()//Debug.getStackTrace(Error);			stack = stack.substring(stack.indexOf("@") + 2);			var i:int = stack.indexOf("@") + 3;			var j:int = stack.indexOf("()", i);			//trace(stack);			//return stack.substring(i, j);			return stack;		}				/**		 * 		 * @param	type		 * @param	... parameters		 * @return		 */		public static function getInstance(type:*, ... parameters:Array):Object		{			try {					var T:*;				if (type is String)					T = getClassByName(type as String);				else if (type is Class)					T = type;				else if (type is Function)					T = type;				else					T = getClassByName(getClassPath(type));				var a:Array = parameters;				switch(a.length)                {					case 0 :						return new T();                    case  1 :                         return new T( a[0] ) ;                    case  2 :                         return new T( a[0], a[1] ) ;                    case  3 :                         return new T( a[0], a[1], a[2] ) ;                                    case  4 :                         return new T( a[0], a[1], a[2], a[3] ) ;                    case  5 :                         return new T( a[0], a[1], a[2], a[3], a[4] ) ;                    case  6 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5] ) ;                    case  7 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6] ) ;                    case  8 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7] ) ;                    case  9 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8] ) ;                    case 10 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9] ) ;                    case 11 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10] ) ;                    case 12 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11] ) ;                    case 13 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12] ) ;                    case 14 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13] ) ;                    case 15 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14] ) ;                    case 16 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15] ) ;                    case 17 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16] ) ;                    case 18 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17] ) ;                    case 19 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18] ) ;                    case 20 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19] ) ;                    case 21 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20] ) ;                    case 22 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21] ) ;                    case 23 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22] ) ;                    case 24 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23] ) ;                    case 25 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24] ) ;                    case 26 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25] ) ;                    case 27 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26] ) ;                    case 28 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27] ) ;                    case 29 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27], a[28] ) ;                    case 30 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27], a[28], a[29] ) ;                    case 31 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27], a[28], a[29], a[30] ) ;                    case 32 :                         return new T( a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27], a[28], a[29], a[30], a[31] ) ;					default:						throw new ArgumentError();                }							} catch (e:Error) {}			return null;		}				/**		 * 		 * @param	instance		 * @param	context		 * @return		 */		public static function getSuperClass(instance:Object, context:ApplicationDomain = null):Class		{ 			try {				return getClassByName(getSuperClassPath(instance), context);			} catch (e:ReferenceError) {}			return null;		}        		/**         * Returns the super class name as string of an object.         * @return the super class name as string of an object.         */						public static function getSuperClassName(instance:Object):String 		{			return parseName(getSuperClassPath(instance));		}        		/**         * Returns the super class package string representation of the specified instance passed in arguments.         * @param o the reference of the object to apply reflexion.         * @return the super class package string representation of the specified instance passed in arguments.         */        public static function getSuperClassPackage(o:*):String         {            return parsePackage(getSuperClassPath(o));        }        		/**         * Returns the super class path string representation of the specified instance passed in arguments.         * @param o the reference of the object to apply reflexion.         * @return the super class path string representation of the specified instance passed in arguments.         */        public static function getSuperClassPath(instance:Object):String         {            return parsePath(getQualifiedSuperName(instance));        }				/**		 * 		 * @param	alias		 * @param	context		 * @return		 */		public static function hasDefinition(alias:String, contextDomain:ApplicationDomain=null):Boolean		{			var domain:ApplicationDomain;				domain = contextDomain || context();			while (!domain.hasDefinition(alias)) {				if (domain.parentDomain)					domain = domain.parentDomain;				else					return false;			}				return true;		}		/**		 * 		 * @param	instance		 * @param	T		 * @return		 */		public static function instanceOf(instance:*, T:Class):Boolean		{			return instance is T;		}				/**		 * 		 * @param	T		 * @return		 */		public static function isInternal(T:*):Boolean		{			return getQualifiedName(T).indexOf("as$") != -1;		}				/**		 * 		 * @param	T		 * @return		 */		public static function isNative(T:*):Boolean		{			return (T is Boolean) || (T is int) || (T is uint) || (T is Number ) || (T is String);		}				/**		 * 		 * @param	T		 * @return		 */		public static function isPrimitive(T:*):Boolean		{			return (T is Boolean) || (T is int) || (T is uint) || (T is Number ) || (T is String);		}               				/**		 * 		 * @param	subClass		 * @param	superClass		 * @return		 */		public static function isSubclassOf(subClass:Class, superClass:Class):Boolean		{			return Class(superClass).isPrototypeOf(subClass);/*superClass.prototype.isPrototypeOf(subClass.prototype);*/		}		        /**         * Copies static and instance methods and properties from mixin to c.         * @param	T Class -          * @param	mixin Class - 	         */        public static function mixin(T:Class, mixin:Class, ... params:Array) : void        {            var typeDesc:Object = parseMixinDesc(mixin);            copyMethodsAndProps(T, mixin, typeDesc['statics']);            copyMethodsAndProps(T.prototype, getInstance(mixin, params), typeDesc['members']);            copyPrototype(T, mixin);            }        		/**         * @private         *           * Copies static methods and properties from mixin to T.         * @param	T Class -         * @param	mixin Class -	         */        public static function mixinStatics (T:Class, mixin:Class) : void        {                copyMethodsAndProps(T, mixin, parseMixinDesc(mixin)['statics']);        }		        /**         * @private         *          * Copies instance methods and properties from the mixin's class instance         * and the mixin's prototype to T's prototype.         * @param	T Class - T type to copy.         * @param	mixin Class - The specified mixin class.          */        public static function mixinMembers (T:Class, mixin:Class) : void        {                copyMethodsAndProps(T.prototype, new mixin(), parseMixinDesc(mixin)['members']);            copyPrototype(T, mixin);        }				/**		 * 		 * @param	T		 * @return		 */		public static function promote(T:Object):Function		{			return null;		}				/**		 * 		 * @param	T		 * @return		 */		public static function register(T:Object):Boolean		{			try {				var c:Class = toClass(T);				var alias:String = parsePath(getQualifiedName(c));				if (ALIAS[alias] == null) {					registerClassAlias(alias, c);					ALIAS[alias] = c;				}								return true;			} catch (e:Error) {}			return false;		}				/**		 * 		 * @param	T		 * @return		 */		public static function toXml(T:Object):XML		{			if(T is String || T is XML || T is XMLList)				T = getDefinitionByName(T.toString());			else if (T is Proxy)				// Proxy subclasses don't have references to their constructors				T = getDefinitionByName(getQualifiedName(T));			else if (!(T is Class))				T = T.constructor;			var alias:String = getQualifiedName(T);			if (alias in DESC)				return DESC[alias];			var info:XML = describeType(T);			DESC[alias] = info;			return info;		}				/**		 * @return an array of <code>Accessor</code> methods		 * @see Accessor		 */		public function get accessors():Array		{			return getAccessorList(_definition["factory"]["accessor"], false);		}				/**		 * @return the name of the inspected class		 */		public function get className():String		{			return _definition.@name;		}				/**		 * @return an array of <code>Variable</code> objects representing all public static constants 		 * within the inspected class		 * @see Variable		 */		public function get constants():Array		{			return getConstantList(_definition["factory"]["constant"], false);		}				/**		 * 		 */		public function get defaultHashCode():int		{			return (isDynamic ? 1 : 0) + (isFinal ? 1 : 0) + (isStatic ? 1 : 0) + accessors.length + constants.length + interfaces.length + metaData.length + methods.length + staticAccessors.length + staticConstants.length + staticMethods.length + staticVariables.length + variables.length;		}				/**		 * @return an array of the names of the interfaces implemented by the inspected class		 */				public function get interfaces():Array 		{ 			return toArray(_definition["factory"]["implementsInterface"], "type"); 		}				/**		 * Mostly returns true because mostly the inspected object is decendent of a class object and 		 * the Class class is dynamic.		 */		public function get isDynamic():Boolean		{			return _definition.@isDynamic == "true";		}		/**		 * @return true if the class is declared as final otherwise returns false		 */		public function get isFinal():Boolean		{			return _definition.@isFinal == "true";		}				/**		 * @return true if the class is declared as static otherwise returns false		 */		public function get isStatic():Boolean		{			return _definition.@isStatic == "true";		}				/**		 * @return an array of <code>MetaData</code> objects representing the classes metadata 		 * if it is present, otherwise returns an empty array		 */		public function get metaData():Array		{			return getMetaDataList(_definition["factory"]["metadata"]);		}		/**		 * @return an array of <code>Method</code> objects representing all public methods within the 		 * inspected class		 * @see Method		 */				public function get methods():Array 		{ 			var tmp:Array = [];			var list:XMLList = _definition["factory"]["method"];			for each (var item:XML in list)				tmp.push({base:_source, name:item.@name, returnType:item.@returnType, params:getParametersList(item), isStatic:false, metadata:getMetaDataList(item["metadata"])});			return tmp;		}			public function get source():Class 		{ 			return _source; 		}				/**		 * @return an array of <code>Accessor</code> methods		 * @see Accessor		 */		public function get staticAccessors():Array		{			return getAccessorList(_definition["factory"]["accessor"], true);		}				/**		 * @return an array of <code>Variable</code> objects representing all public constants within 		 * the inspected class		 * @see Variable		 */		public function get staticConstants():Array		{			return getConstantList(_definition["constant"], true);		}				/**		 * @return an array of <code>Method</code> objects representing all public static methods 		 * within the inspected class		 * @see Method		 */		public function get staticMethods():Array		{			var tmp:Array = [];			var list:XMLList = _definition["method"];			for each (var item:XML in list)				tmp.push({base:_source, name:item.@name, returnType:item.@returnType, params:getParametersList(item), isStatic:true, metadata:getMetaDataList(item["metadata"])});			return tmp;		}				/**		 * @return an array of <code>Variable</code> objects representing all public static variables 		 * within the inspected class 		 * @see Variable		 */		public function get staticVariables():Array		{			return getVariablesList(_definition["variable"], true);		}				/**		 * @return the superclass of the inspected class		 */		public function get superClassName():String		{			return toArray(_definition["factory"]["extendsClass"], "type")[0];		}				/**		 * @return an array of <code>Variable</code> objects representing all public variables within 		 * the inspected class		 * @see Variable		 */		public function get variables():Array		{			//trace(_definition["factory"]);			return getVariablesList(_definition["factory"]["variable"], false);		}				/**		 * 		 * @param	list		 * @param	isStatic		 * @return		 */		private function getAccessorList(list:XMLList, isStatic:Boolean):Array		{			var tmp:Array = [];			for each (var item:XML in list)				tmp.push({source:_source, name:item.@name, access:item.@access, type:item.@type, isStatic:isStatic, metadata:getMetaDataList(item["metadata"]) } );			return tmp;		}				/**		 * 		 * @param	list		 * @param	isStatic		 * @return		 */		private function getConstantList(list:XMLList, isStatic:Boolean):Array		{			var tmp:Array = [];			for each (var item:XML in list)				tmp.push({base:_source, name:item.@name, type:item.@type, isStatic:isStatic});			return tmp;		}				/**		 * 		 * @param	metaData		 * @return		 */		private function getMetaDataList(metaData:XMLList):Array		{			if(metaData == null) return null;						var metaDataAr:Array = [];			for each (var data : XML in metaData) {				var name:String = data.@name;				if(name == "") continue;				var argsAr:Array = new Array;				for each (var node : * in data["arg"]) 					argsAr.push({key:String(node.@key), value:node.@value});				metaDataAr.push({name:name, parameters:argsAr});			} 			return metaDataAr;		}				/**		 * 		 * @param	method		 * @return		 */		private function getParametersList(method:XML):Array		{			var tmp:Array = [];			var list:XMLList = method["parameter"];			for each (var item:XML in list)				tmp.push({index:item.@index, type:item.@type, optional:item.@optional == "true"});			return tmp;		}				/**		 * 		 * @param	list		 * @param	isStatic		 * @return		 */		private function getVariablesList(list:XMLList, isStatic:Boolean):Array		{			var tmp:Array = [];			for each (var item:XML in list)				tmp.push({base:_source, name:item.@name, type:item.@type, isStatic:isStatic, metadata:getMetaDataList(item["metadata"]) } );			return tmp;		}			                       		   		/**		 * @private		 * 		 * @param	recipient Object -		 * @param	source Object -		 * @param	definition Object -		 */             private static function copyMethodsAndProps (recipient:Object, source:Object, definition:Object):void        {            for each (var method:String in definition['methods'])                recipient[method] = source[method];                        for each (var prop : String in definition['properties'])                recipient[prop] = source[prop];                    } 				/**		 * 		 * @param	source		 * @param	destination		 * @param	overrides		 * @return		 */		private static function copyObject(source:Object, destination:Object, overrides:Boolean):Object		{			var p:String			for (p in source) {				if ((destination[p] == source[p] && !overrides))					continue;				else					destination[p] = source[p];			}				return destination;		}				/**		 * @private		 * 		 * @param	recipient Object -		 * @param	source Object -		 */                private static function copyPrototype (destination:Class, source:Class) : void        {            for (var protoProp:String in source.prototype)                destination.prototype[protoProp] = source.prototype[protoProp];                    }				/**		 * 		 * @param	r		 * @param	s		 * @param	replace		 */		private static function dontEnum(r:Object, s:Object, replace:Boolean):void		{            var enums:Array = ['constructor', 'toString', 'toLocaleString', 'isPrototypeOf', 'propertyIsEnumerable', 'hasOwnProperty', 'valueOf'];                                   if (s is Function)                 enums.push('call', 'apply', 'prototype');                        var l:int = enums.length, i:int = 0, p:String;            do {                p = enums[i];                if (!s.hasOwnProperty(p) || r[p] === s[p])                     continue;                if (replace || !r.hasOwnProperty(p))                     r[p] = s[p];            }            while (i++ < enums.length)        }        				/**		 * 		 * @param	path		 * @return		 */		private static function parseName(path:String):String         {            var a:Array = path.split(ACCESSOR) ;            return (a.length > 1) ? a.pop( ) : path ;        }  		   		/**		 * @private		 * 		 * @param	T Class -		 * @return	Object -		 */                private static function parseMixinDesc (T:Class):Object        {            var desc:XML = toXml(T);            			var staticMethods:Array = [];            var staticProperties:Array = [];            var memberMethods:Array = [];            var memberProperties:Array = [];                        for (var f:String in desc.method)                staticMethods.push(desc.method.@name[f]);                        for (var l:String in desc.variable)                staticProperties.push(desc.variable.@name[l]);                            for (var e:String in desc.factory.method)                memberMethods.push(desc.factory.method.@name[e]);                        for (var x:String in desc.factory.variable)                memberProperties.push(desc.factory.variable.@name[x]);                        return {statics:{methods: staticMethods, properties : staticProperties},                     members:{methods: memberMethods, properties : memberProperties}};        }        		/**		 * 		 * @param	path		 * @return		 */		private static function parsePackage(path:String):String         {            var a:Array = path.split(ACCESSOR) ;            if (a.length > 1)                return a.pop().join(ACCESSOR) ;			return null;        }        			/**		 * Since there is no way to reflectively invoke namespace scoped methods we will		 * not add them. But there is the edge case that interface methods have an uri		 * that equals the fully qualified name of the interface. That is the only case where		 * we accept an uri attribute.		 * 		 * @return whether we accept the type as a public member		 */		private static function representsPublicMember(xml:XML) : Boolean 		{			//TODO: implements Type.representsPublicMember properly			return false;//(xml.@uri.length() == 0 || _interface);		}				/**		 * 		 * @param	path		 * @return		 */		private static function parsePath(path:String):String         {						if (path.indexOf("as$") != -1) {				var pkg:Array = path.split(ACCESSOR);				var superClass:String = pkg[0];				var internalClass:Array = path.split(QUALIFIED_ACCESSOR);				return superClass + "." + internalClass[internalClass.length - 1];			}            return path.split(QUALIFIED_ACCESSOR).join(ACCESSOR);        } 				/**		 * 		 * @param	list		 * @param	attribute		 * @return		 */		private static function toArray(list:XMLList, attribute:String):Array		{			var tmp:Array = [];			for each (var item:XML in list)				tmp.push(item["@" + attribute]);			return tmp;		}				/**		 * 		 * @param	T		 * @param	contex		 * @return		 */		private static function toClass(T:*, contex:ApplicationDomain=null):Class		{			try {				var c:Class;				if (T is Class)					c = T as Class;				else if (T is String)					c = getClassByName(T);				else					c = getClass(T);				return c;			} catch (e:Error) { }			return null;		}					protected static var ALIAS:Dictionary = new Dictionary(true);				protected static var DESC:Dictionary = new Dictionary(true);			private var _definition:XML;		private var _source:Class;	}	}